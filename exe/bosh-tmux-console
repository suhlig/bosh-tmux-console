#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift(File.expand_path('../../lib', __FILE__))

require 'bosh/director'
require 'tmux/client'

def die(msg)
  warn "Error: #{msg}"
  exit(1)
end

deployment = ARGV.first || die('Missing argument for deployment name')
session_name = "bosh-#{deployment}"
client = TMux::Client.new

if client.session?(session_name)
  die 'Not creating new windows because there already is an existing tmux ' \
      "session named #{session_name}. Consider nuking it with:\n" \
      "tmux kill-session -t #{session_name}"
end

# TODO: Replace with new factory method:
# BOSH::Director.from_file('~/.bosh_config')
require 'yaml'
require 'pathname'
config = YAML.load_file(Pathname('~/.bosh_config').expand_path)
director_url = config['target'] # e.g. https://192.168.50.4:25555
director_auth = config['auth'][director_url] # username + password
director = BOSH::Director.new(director_url,
                              director_auth['username'],
                              director_auth['password'],
                              verify_ssl: :none)

session = nil

director.vms(deployment).each do |vm|
  window_name = "#{vm['job']}/#{vm['index']}"
  shell_command = "bosh ssh #{vm['job']}/#{vm['index']}"

  # TODO: Does this make sense?
  # window = client.find_or_create_window(session_name, window_name, shell_command)

  # tmux has no way to create a session without an initial window, so we have
  # to provide the command for the first window when creating the session.
  window = if session.nil?
             session = client.create_session(session_name, window_name, shell_command)
             session.window(window_name)
           else
             session.create_window(window_name, shell_command)
           end

  window.type('sudo su -', 'cd /var/vcap')

  # split off the monit pane
  # TODO: The watch command goes to the wrong pane
  window.
    split(shell_command: shell_command,
          direction: :vertical,
          size: 10).
    type('sudo watch -n 1 /var/vcap/bosh/bin/monit summary')
end

client.switch(session_name)

# materialize the collected commands into a single script
puts client.commands.join(";\n")
